player_data |>
arrange(desc(predicted_2026_points))
#| label: export_player_points
write_csv(player_data,"processed_data/player_data.csv")
#|label: import-points-predictions
library(tidyverse)
library(tidymodels)
player_data <- read_csv("processed_data/player_data.csv")
#| label: team-functions
example_team <- player_data |> filter(
web_name %in% c(
"Pickford",
"Sels",
"Gvardiol",
"Murillo",
"Mings",
"Pinnock",
"Aina",
"M.Salah",
"Joelinton",
"Rogers",
"J.Murphy",
"Kluivert",
"Bowen",
"Wissa",
"Mateta"
)
)
# Check if it's a legal team (not cost)
team_checker <- function(team) {
is_15 <- nrow(team) == 15
is_2_GK <- nrow(team |> filter (element_type == 1)) == 2
is_5_DF <- nrow(team |> filter (element_type == 2)) == 5
is_5_MD <- nrow(team |> filter (element_type == 3)) == 5
is_3_FW <- nrow(team |> filter (element_type == 4)) == 3
teams_with_over_3 <- count(team, short_name, sort = TRUE) |>
filter(n > 3)
max_three_per_team <- nrow(teams_with_over_3) == 0
all(is_15, is_2_GK, is_5_DF, is_5_MD, is_3_FW, max_three_per_team)
}
team_checker(example_team)
# Also need a checker of if it's on the way to being a legal team:
partial_team_checker <- function(team) {
is_15 <- nrow(team) <= 15
is_2_GK <- nrow(team |> filter (element_type == 1)) <= 2
is_5_DF <- nrow(team |> filter (element_type == 2)) <= 5
is_5_MD <- nrow(team |> filter (element_type == 3)) <= 5
is_3_FW <- nrow(team |> filter (element_type == 4)) <= 3
teams_with_over_3 <- count(team, short_name, sort = TRUE) |>
filter(n > 3)
max_three_per_team <- nrow(teams_with_over_3) == 0
all(is_15, is_2_GK, is_5_DF, is_5_MD, is_3_FW, max_three_per_team)
}
# Check cost
team_cost <- function(team) {
team |> summarise(total = sum(now_cost, na.rm = TRUE)) |> pull(total)
}
team_cost(example_team)
# Calculate team score
team_score <- function(team) {
# Set out likely weights for play time (can optimise later)
weights <- tribble(
~weight, 0.7, 0.3, 1, 1, 0.7, 0.7, 0.6, 1.5, 1.3, 1, 0.6, 0.4, 1.2, 0.6, 0.4
)
#organise to be in the right order for weighting
team|>
arrange(desc(predicted_2026_points)) |>
arrange(element_type) |>
# then weight according to likely play time and captaincy and sum
cbind(weights)|>
mutate(weighted_score = predicted_2026_points * weights) |>
summarise(total = sum(weighted_score))|>
pull()
}
team_score(example_team)
#| label: eliminate-dominated-players
# Calculate rank of whether players are the best for their cost in their category
ranked_players <- player_data |>
group_by(element_name) |>
mutate(
dominance_rank = map2_int(predicted_2026_points, now_cost, ~ {
# compare against this group's rows with cost <= this row's cost
pool <- predicted_2026_points[now_cost <= .y]
1L + sum(pool > .x)   # rank 1 = best; use >= for min-rank ties
})
) |>
ungroup() |>
relocate(dominance_rank, predicted_2026_points)|>
arrange(dominance_rank) |>
filter(dominance_rank <=5)
# For the algorithms, only want the top 5 ranks for each cost
#| label: create-seeds
# Set up cost parameters
element_limits <- tribble(
~.category, ~ .target,
"GK", 2,
"DEF", 5,
"MID", 5,
"FWD", 3
)
cost_penalty <- c(GK = 2, DEF = 5, MID = 5, FWD = 3)
budget <- 1000
greedy_seed_hard_capped <- function(
df,
budget,
n_runs = 5,
rng_seeds = NULL,
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points",
max_iter  = 40
) {
# ---- Hard-coded category targets (EDIT THESE) ----
# Example FPL-style squad shape that sums to 15:
targets_tbl <- tribble(
~.category, ~.target,
"GK",        2L,
"DEF",        5L,
"MID",        5L,
"FWD",        3L
)
# --------------------------------------------------
# Build working frame with standardized temp columns
X <- df %>%
transmute(
.id       = .data[[id_col]],
.category = as.character(.data[[cat_col]]),   # ensure character for joining
.cost     = as.numeric(.data[[cost_col]]),
.value    = as.numeric(.data[[score_col]])
)
# Check that all categories present in X exist in targets
miss <- setdiff(unique(X$.category), targets_tbl$.category)
if (length(miss)) {
stop("Missing targets for categories: ", paste(miss, collapse = ", "), call. = FALSE)
}
# helper: run ONE jittered greedy seed
run_one_seed <- function(z_vec) {
# Helper: given alpha, rank within each category and take the top N for that category
pick_with_alpha <- function(alpha) {
base_key <- X$.value - alpha * X$.cost
sigma <- sd(base_key)
if (!is.finite(sigma) || sigma == 0) sigma <- 0
eps   <- rnorm(nrow(X), sd = 1e-6)
key <- base_key + 0.3 * sigma * z_vec + eps  # jitter with sd = 0.2 * sd(key)
cand <- X %>%
mutate(
.key      = key,
.tiebreak = .value / pmax(.cost, 1e-9)
) %>%
arrange(.category, desc(.key), desc(.tiebreak), desc(.value), .cost) %>%
left_join(targets_tbl, by = join_by(.category))
# Slice per category using the joined .target (guaranteed scalar per group)
M_factor <- 2L
chosen <- cand %>%
group_by(.category) %>%
group_modify(~ {
.x <- .x
t <- as.integer(.x$.target[1])            # required picks for this category
if (is.na(t) || t <= 0L) return(.x[0, ])  # nothing to pick
# frontier size: top M rows within this category
M <- min(nrow(.x), max(t, M_factor * t))
frontier <- .x[1:M, , drop = FALSE]
# compute softmax-like weights from .key
k <- frontier$.key
k[!is.finite(k)] <- min(k[is.finite(k)], na.rm = TRUE)
kmax <- max(k, na.rm = TRUE)
tau  <- sd(k, na.rm = TRUE)
if (!is.finite(tau) || tau <= 0) tau <- 1  # avoid divide-by-zero
w <- exp((k - kmax) / tau)
# fallbacks if weights misbehave
if (any(!is.finite(w)) || any(is.na(w)) || all(w <= 0)) {
w <- rep(1, length(k))
}
# sample WITHOUT replacement using 'sample()', not sample.int()
idx <- sample(seq_len(nrow(frontier)), size = t, replace = FALSE, prob = w)
frontier[idx, , drop = FALSE]
}) %>%
ungroup()
list(
chosen      = chosen,
total_cost  = sum(chosen$.cost),
total_value = sum(chosen$.value)
)
}
# ---- Binary search on alpha to meet budget ----
alpha_lo  <- 0
alpha_hi  <- 10      # start; will expand if needed
best      <- NULL
# Ensure alpha_hi is tight enough to get under budget
for (k in 1:10) {
trial <- pick_with_alpha(alpha_hi)
best  <- trial
if (trial$total_cost <= budget) break
alpha_hi <- alpha_hi * 2
}
if (best$total_cost > budget) {
warning("Could not meet budget even with strong cost penalty; returning cheapest-by-penalty pick.")
return(list(
selection   = best$chosen %>% select(.id, .category, now_cost = .cost, score = .value),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
))
}
for (it in 1:max_iter) {
alpha_mid <- 0.5 * (alpha_lo + alpha_hi)
trial <- pick_with_alpha(alpha_mid)
if (trial$total_cost <= budget) {
best <- trial
alpha_hi <- alpha_mid
} else {
alpha_lo <- alpha_mid
}
if (abs(trial$total_cost - budget) <= 1e-6 || (alpha_hi - alpha_lo) < 1e-4) break
}
# ----------------------------------------------
# Return tidy outputs
list(
selection   = best$chosen %>%
select(.id, .category, now_cost = .cost, score = .value) %>%
arrange(.category, desc(score)),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
)
}
# --- prepare jitter z-vectors for each run ---
if (is.null(rng_seeds)) {
z_list <- replicate(n_runs, rnorm(nrow(X)), simplify = FALSE)
} else {
stopifnot(length(rng_seeds) >= n_runs)
z_list <- map(seq_len(n_runs), ~ { set.seed(rng_seeds[.x]); rnorm(nrow(X)) })
}
# ---  run the greedy seed multiple times and store ---
seeds <- map(z_list, run_one_seed)
summary <- tibble(
run         = seq_len(n_runs),
total_cost  = map_dbl(seeds, "total_cost"),
total_value = map_dbl(seeds, "total_value"),
alpha_used  = map_dbl(seeds, "alpha_used")
)
#--- order seeds by total_value (descending) ---
order_idx <- order(summary$total_value, decreasing = TRUE)
seeds <- seeds[order_idx]
summary <- summary[order_idx, ] %>%
mutate(run = seq_len(n()))
list(seeds = seeds, summary = summary)
}
seeds <- greedy_seed_hard_capped(ranked_players,
budget,
n=5
)
# Give the outcome of the best changes
seeds$summary
# What is the best team emerging from the seeds, for info
best_seed <- seeds$seeds[[1]]$selection |> left_join(ranked_players|> select(id, web_name), by = join_by(.id == id))|> print(n=16)
#Is that team legal?
team_checker(seeds$seeds[[1]]$selection |> left_join(ranked_players, by = join_by(.id == id)))
# This created a legal team but we got lucky with it - didn't check on the way through that it worked. Should come back and fix this to something I am happy with.
best_seed
best_pairwise_swap <- function(
df,        # full player table (ranked_players)
chosen,    # tibble of current picks (has .id)
budget,
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
) {
# Extract chosen IDs from `.id` column in chosen
chosen_ids <- chosen$.id
# Build chosen / unchosen views from df
chosen_tbl <- df %>%
filter(id %in% chosen_ids) %>%
transmute(
out_id    = id,
category  = .data[[cat_col]],
out_cost  = .data[[cost_col]],
out_score = .data[[score_col]]
)
unchosen_tbl <- df %>%
filter(!(id %in% chosen_ids)) %>%
transmute(
in_id    = id,
category = .data[[cat_col]],
in_cost  = .data[[cost_col]],
in_score = .data[[score_col]]
)
# Current totals
current_cost  <- sum(chosen_tbl$out_cost, na.rm = TRUE)
current_score <- sum(chosen_tbl$out_score, na.rm = TRUE)
leftover      <- budget - current_cost
# Join within same category; look for feasible improving swaps
cand_pairs <- inner_join(chosen_tbl, unchosen_tbl, by = "category") %>%
mutate(
delta_cost  = in_cost  - out_cost,
delta_score = in_score - out_score,
feasible    = (delta_cost <= leftover)
) %>%
filter(feasible, delta_score > 0)
if (nrow(cand_pairs) == 0) return(NULL)
# Pick best swap: highest score gain, then lowest extra cost, then best incoming score
best <- cand_pairs %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice(1)
list(
out_id          = best$out_id,
in_id           = best$in_id,
delta_score     = as.numeric(best$delta_score),
delta_cost      = as.numeric(best$delta_cost),
new_total_cost  = as.numeric(current_cost + best$delta_cost),
new_total_score = as.numeric(current_score + best$delta_score)
)
}
stochastic_local_search <- function(
ranked_players,   # full pool
team,             # tibble with .id for current picks
budget,
n_steps   = 400,
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points",
tabu_len  = 2,      # small tabu to reduce back-and-forth during anneal
pick_bias = 0.6     # bias to choose a lower-scoring 'out' player
) {
# --- Prepare pool ---
pool <- ranked_players %>%
transmute(
id    = .data[["id"]],
cat   = .data[[cat_col]],
cost  = .data[[cost_col]],
score = .data[[score_col]]
)
idx_by_cat <- split(seq_len(nrow(pool)), pool$cat)
# Current team state
team_ids <- as.vector(team$.id)
cur_cost  <- sum(pool$cost[match(team_ids, pool$id)])
cur_score <- sum(pool$score[match(team_ids, pool$id)])
if (cur_cost > budget) stop("Initial team exceeds budget.", call. = FALSE)
# Best-so-far snapshot
best_ids   <- team_ids
best_cost  <- cur_cost
best_score <- cur_score
# Simple tabu memory (by id) during anneal
tabu_queue <- character(0)
# --- helpers ---
feasible_swaps_for <- function(out_id, current_ids = team_ids, current_cost = cur_cost) {
r <- pool[pool$id == out_id, ]
leftover <- budget - current_cost
cand_idx <- setdiff(idx_by_cat[[as.character(r$cat)]], match(current_ids, pool$id))
if (length(cand_idx) == 0) return(NULL)
tibble(
in_id       = pool$id[cand_idx],
in_cost     = pool$cost[cand_idx],
in_score    = pool$score[cand_idx],
delta_cost  = pool$cost[cand_idx]  - r$cost,
delta_score = pool$score[cand_idx] - r$score
) %>%
filter(delta_cost <= leftover)
}
pick_out <- function(current_ids = team_ids) {
team_rows <- pool[match(current_ids, pool$id), ]
if (runif(1) < pick_bias) {
ord <- order(team_rows$score, decreasing = FALSE)
pick_set <- team_rows$id[ord[seq_len(max(1, length(ord) %/% 2))]]
sample(pick_set, 1)
} else {
sample(current_ids, 1)
}
}
# Cooling schedule (simulated annealing)
T0 <- max(1, sd(pool$score, na.rm = TRUE))
temp <- function(step) T0 * (1 - (step - 1) / max(1, n_steps))
# --- main annealing loop ---
for (i in seq_len(n_steps)) {
out_id <- pick_out()
fs <- feasible_swaps_for(out_id) %>%
filter(!(in_id %in% tabu_queue))
if (!is.null(fs) && nrow(fs)) {
# best improving swap first
improving <- fs %>%
filter(delta_score > 0) %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice_head(n = 1)
if (nrow(improving)) {
in_id <- improving$in_id
team_ids <- c(setdiff(team_ids, out_id), in_id)
cur_cost  <- cur_cost  + improving$delta_cost
cur_score <- cur_score + improving$delta_score
tabu_queue <- c(tabu_queue, out_id, in_id)
if (length(tabu_queue) > 2 * tabu_len) tabu_queue <- tail(tabu_queue, 2 * tabu_len)
} else {
# least-damaging feasible swap; accept with Metropolis prob
candidate <- fs %>% arrange(delta_score, delta_cost) %>% slice_head(n = 1)
dS <- candidate$delta_score
T  <- temp(i)
if (!is.na(dS) && runif(1) < exp(dS / max(1e-9, T))) {
in_id <- candidate$in_id
team_ids <- c(setdiff(team_ids, out_id), in_id)
cur_cost  <- cur_cost  + candidate$delta_cost
cur_score <- cur_score + candidate$delta_score
tabu_queue <- c(tabu_queue, out_id, in_id)
if (length(tabu_queue) > 2 * tabu_len) tabu_queue <- tail(tabu_queue, 2 * tabu_len)
}
}
# update best-so-far
if (cur_score > best_score && cur_cost <= budget) {
best_ids   <- team_ids
best_cost  <- cur_cost
best_score <- cur_score
}
}
}
# --- FINAL HILL-CLIMB PASS (one sweep) ---
# Start from best-so-far, iterate once through each position and apply the best improving swap if any.
team_ids <- best_ids
cur_cost  <- best_cost
cur_score <- best_score
for (out_id in team_ids) {
fs <- feasible_swaps_for(out_id, current_ids = team_ids, current_cost = cur_cost)
if (!is.null(fs) && nrow(fs)) {
improving <- fs %>%
filter(delta_score > 0) %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice_head(n = 1)
if (nrow(improving)) {
in_id <- improving$in_id
team_ids <- c(setdiff(team_ids, out_id), in_id)
cur_cost  <- cur_cost  + improving$delta_cost
cur_score <- cur_score + improving$delta_score
}
}
}
# Return the post-hill-climb team
list(
team_ids    = team_ids,
team        = pool %>% filter(id %in% team_ids) %>% arrange(cat, desc(score)),
total_cost  = cur_cost,
total_score = cur_score
)
}
stochastic_output <- stochastic_local_search(ranked_players, best_seed, 1000)
stochastic_output <- stochastic_local_search(ranked_players, best_seed, 1000)
stochastic_team <- stochastic_output$team|> left_join(ranked_players, by = join_by(id == id))
stochastic_team
budget <- 1000
# ---- Phase A: 24 seeds × 1000 steps (≈ 5 mins on most laptops) ----
set.seed(125)
phaseA <- greedy_seed_hard_capped(
df        = ranked_players,
budget    = budget,
n_runs    = 24,
rng_seeds = sample.int(1e6, 24),
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
)
anneal_A <- imap(phaseA$seeds, ~ {
set.seed(1000 + .y)
stochastic_local_search(
ranked_players = ranked_players,
team           = .x$selection,   # has .id
budget         = budget,
n_steps        = 1000,            # shallow
cat_col        = "element_name",
cost_col       = "now_cost",
score_col      = "predicted_2026_points",
tabu_len       = 2,
pick_bias      = 0.8
)
})
summary_A <- tibble(
idx         = seq_along(anneal_A),
total_score = map_dbl(anneal_A, "total_score"),
total_cost  = map_dbl(anneal_A, "total_cost")
) %>% arrange(desc(total_score))
summary_A
# ---- Phase B: deepen the best 5 seeds if different × 3000 steps (≈ 5–7 mins) ----
top_k <- head(summary_A$idx, 5)
anneal_B <- map(top_k, ~
stochastic_local_search(
ranked_players = ranked_players,
team           = phaseA$seeds[[.x]]$selection,
budget         = budget,
n_steps        = 3000,           # deep
cat_col        = "element_name",
cost_col       = "now_cost",
score_col      = "predicted_2026_points",
tabu_len       = 2,
pick_bias      = 0.6
)
)
summary_B <- tibble(
seed_from_A  = top_k,
total_score  = map_dbl(anneal_B, "total_score"),
total_cost   = map_dbl(anneal_B, "total_cost")
) %>% arrange(desc(total_score))
summary_B
best_idx
best_idx
best_idx
best_team  <- anneal_B[[best_idx]]$team
best_score <- anneal_B[[best_idx]]$total_score
best_cost  <- anneal_B[[best_idx]]$total_cost
best_score
best_cost
best_team |> left_join(ranked_players|> select(id, web_name), by = join_by(id == id))|> print(n=16)
best_team |> left_join(ranked_players|> select(id, web_name), by = join_by(id == id))|> print(n=16)
q()
