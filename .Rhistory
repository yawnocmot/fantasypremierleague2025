GW,
kickoff_time = date_utc,
goals_scored,
assists,
minutes,
team,
id_2026)
fpl_player_fixtures <- fpl_gw |>
left_join(player_data, join_by(id_2026 == id))|>
select(web_name,
GW,
goals_scored,
assists,
minutes,
team,
team_code,
id_2026) |>
left_join(fixtures_poisson_format|> filter(season_end == 2026), by = join_by(team == attacker_name, GW == round_number)) |>
select(name = web_name,
GW,
kickoff_time = date_utc,
goals_scored,
assists,
minutes,
team,
id_2026)
fpl_player_fixtures
#| label: player-data
# Lots of data in the fpl_elements tab - for now we need name, ID, element type, team_code, now_cost. Might come back for other data.
player_data <- fpl_elements |>
select(
first_name, second_name, web_name, id,
element_type, team_code, now_cost, minutes_fpl = minutes,
play_chance = chance_of_playing_next_round
) |>
left_join(team_name_finder, join_by(team_code == code)) |>
mutate(element_name = case_when(
element_type == 1 ~ "GK",
element_type == 2 ~ "DEF",
element_type == 3 ~ "MID",
element_type == 4 ~ "FWD",
.default = NA
)
)
# Have gw data from fpl input - bring in webname, team and kick-off time
fpl_player_fixtures <- fpl_gw |>
left_join(player_data, join_by(id_2026 == id))|>
select(web_name,
GW,
goals_scored,
assists,
minutes,
team,
team_code,
id_2026) |>
left_join(fixtures_poisson_format|> filter(season_end == 2026), by = join_by(team == attacker_name, GW == round_number)) |>
select(name = web_name,
GW,
kickoff_time = date_utc,
goals_scored,
assists,
minutes,
team,
id_2026)
# WARNING: When there are double game weeks this will break.
player_fixture_data <- vaastav_2025 |>
select(!id_2025)|>
rbind(fpl_player_fixtures)
# Create an exponential back-off summary for goals scored, assists, and minutes in Vaastav data
decay_parameter <- 0.005
player_2025_summary <- player_fixture_data |>
filter(!is.na(id_2026))|>
mutate(
assists = as.numeric(assists),
minutes_any = as.numeric(minutes>0),
minutes_60_plus = as.numeric(minutes>60),
days_ago = (today() %--% kickoff_time)/days(1),
weight = exp(decay_parameter*days_ago)
)|>
group_by(id_2026)|>
summarise(
minutes_any_weighted = weighted.mean(minutes_any,weight),
minutes_60_weighted = weighted.mean(minutes_60_plus,weight),
goals_weighted = weighted.mean(goals_scored, weight),
assists_weighted = weighted.mean(assists, weight)
)
# Bit of a problem that for teams/players with no 2025 data, assumption in GW is that every week will be like GW 1 - so new players who happened to score/assist have done very well. It should settle down soon..
# Now match this to our player dataset
player_data <- player_data|>
left_join(player_2025_summary, join_by(id == id_2026))
# Which players don't have a match? 164 now, out of 663. Let's look by team
player_data |>
filter(is.na(minutes_any_weighted))|>
count(short_name,sort = TRUE)
# Sunderland, Burnley and Leeds have high numbers which is to be expected, but account for less than half of the total. The rest are those with high numbers of transfers, but let's take a closer look and flag those where you would expect a match.
# Is there a new player flag in the dataset? Well not explicit - but past payers have data from the previous season. Best we can do is minutes - won't reveal which players have data which didn't match, but didn't get any minutes. That's kind of fine though!
changed_name <- player_data |>
filter(minutes_fpl>0,
is.na(minutes_any_weighted))|>
mutate(name = str_c(first_name, " ", second_name),.before = 1)
changed_name
# This is the problem list - went back and hard-coded. Possible this will change as transfers happen (e.g. if an Ipswich player joins a PL team). So check again.
# Rest of the players with missing data are new to the PL - we need to create some data for them.
# For newly promoted teams take data from Championship. A few players played more than once. Also some might have the same name... Not worried about players who played in championship and prem - just use prem data - rows_patch will help this.
fpl_champ_players <- champ_players_2025 |>
filter(!is.na(id_2026))|>
mutate(minutes_any_weighted = minutes_any/46,
minutes_60_weighted = minutes_any/46,
goals_weighted = goals/46,
assists_weighted = assists/46)|>
group_by(id_2026)|>
summarise(
minutes_any_weighted = sum(minutes_any_weighted),
minutes_60_weighted = sum(minutes_60_weighted),
goals_weighted = sum(goals_weighted),
assists_weighted = sum(assists_weighted)
)|>
rename(id = id_2026)
player_data <- player_data|>
rows_patch(fpl_champ_players)
# Check again by team:
player_data |>
filter(is.na(minutes_any_weighted)) |>
count(short_name,sort = TRUE)
# Down to 106, Sunderland still very high - have a look through the players if something has gone wrong with names. No - looks like Sunderland just have loads of new players. So done here.
# For incoming players, create dummy data based on team-mates - take the worst player in that position (conservative approach). For keepers assume they won't play.
worst_player <- player_data |>
group_by(element_type, team_code) |>
summarise(
minutes_any_weighted = min(minutes_any_weighted, na.rm = TRUE),
minutes_60_weighted = min(minutes_60_weighted, na.rm = TRUE),
goals_weighted = min(goals_weighted, na.rm = TRUE),
assists_weighted = min(assists_weighted, na.rm = TRUE)
)|>
mutate(
minutes_any_weighted = if_else(element_type == 1,
0,
minutes_any_weighted),
minutes_60_weighted = if_else(element_type == 1,
0,
minutes_60_weighted)
)
new_player_dummy <- player_data |>
filter(is.na(minutes_any_weighted))|>
select(id, team_code, element_type)|>
left_join(worst_player, join_by(team_code == team_code, element_type == element_type))
player_data <- player_data |>
rows_patch(new_player_dummy)
# Want to scale back GK in particular to make sure that there aren't two which will play loads of minutes
keeper_minutes <- player_data |>
filter(element_type==1)|>
group_by(short_name)|>
summarise(
keeper_time = sum(minutes_60_weighted)
)
player_data <- player_data |>
left_join(keeper_minutes) |>
mutate(
minutes_any_weighted = if_else(
element_type == 1 & keeper_time > 1,
minutes_any_weighted / keeper_time,
minutes_any_weighted
),
minutes_60_weighted = if_else(
element_type == 1 & keeper_time > 1,
minutes_60_weighted / keeper_time,
minutes_60_weighted
)
)
#| label: player-score-predict
# First step is to work out proportion of goals and assists the player will get for their team:
# Summarise goals and assists per team
goals_per_team <- player_data |>
group_by(team_code)|>
summarise(team_goals = sum(goals_weighted),
team_assists = sum(assists_weighted))
# Look at what proportion are scored by each player
player_data <- player_data |>
left_join(goals_per_team) |>
mutate(prop_goals = goals_weighted/team_goals,
prop_assists = assists_weighted/team_assists)
# Next to look at goals/clean sheets the team will score at upcoming matches, with a decay parameter
# Adjust predict_future_rows to give key info per team each game week.
team_scores_per_week <- predict_future_rows |>
pivot_longer(
cols = c(home, away),
names_to = "home_or_away",
values_to = "goals"
) |>
mutate(
attacker_short_name = if_else(home_or_away == "home",
home_short_name,
away_short_name),
defender_short_name = if_else(home_or_away == "home",
away_short_name,
home_short_name),
prob_clean_sheet = if_else(home_or_away == "home",
prob_home_clean_sheet,
prob_away_clean_sheet),
prob_concede_2 = if_else(home_or_away == "home",
prob_home_concede_2,
prob_away_concede_2),
prob_concede_4 = if_else(home_or_away == "home",
prob_home_concede_4,
prob_away_concede_4)
) |>
select(round_number, match_number, date_utc, home_or_away,
attacker_short_name, defender_short_name, goals, prob_clean_sheet,
prob_concede_2, prob_concede_4)
future_decay_parameter <- 0.005
goals_against <- team_scores_per_week |>
mutate (
days_from_now = (date_utc %--% today())/days(1),
weight = exp(decay_parameter*days_from_now)
) |>
group_by(defender_short_name)|>
summarise(
weighted_2026_goals_against = sum(goals*weight)
) |>
rename(short_name = defender_short_name)
team_weighted_stats <- team_scores_per_week |>
mutate (
days_from_now = (date_utc %--% today())/days(1),
weight = exp(decay_parameter*days_from_now)
) |>
group_by(attacker_short_name)|>
summarise(
weighted_2026_goals = sum(goals*weight),
weighted_2026_clean_sheets = sum(prob_clean_sheet*weight),
weighted_2026_concede_2 = sum(prob_concede_2*weight),
weighted_2026_concede_4 = sum(prob_concede_4*weight),
weighted_2026_games = sum(weight)
) |>
rename(short_name = attacker_short_name)|>
left_join(goals_against)
# Come back to this - account for wildcards etc. to have time limits. Is it better in fact to match at a gameweek level - bigger file but more flexibility.
# Finally turn this into estimated points
# Bring together player and team data
player_data <- player_data |>
left_join(team_weighted_stats) |>
mutate(
goals_predict_2026 = prop_goals * weighted_2026_goals,
assists_predict_2026 = prop_assists * weighted_2026_goals,
play_predict_2026 = minutes_any_weighted * weighted_2026_games +
minutes_60_weighted * weighted_2026_games,
goals_against_predict_2026 = minutes_any_weighted * weighted_2026_goals_against,
clean_sheets_predict_2026 = minutes_60_weighted * weighted_2026_clean_sheets,
concede_2_predict_2026 = minutes_60_weighted * weighted_2026_concede_2,
concede_4_predict_2026 = minutes_60_weighted * weighted_2026_concede_4
) |>
#Chance to edit if needed:
mutate(play_chance = case_when(
id == 47 ~ 75,
TRUE    ~ play_chance
)) |>
mutate(
predicted_2026_points = case_when(
element_type == 1 ~ play_predict_2026 + 4*clean_sheets_predict_2026
+ 10*goals_predict_2026 + 3*assists_predict_2026
- 0.5*goals_against_predict_2026
- concede_2_predict_2026 - concede_4_predict_2026,
element_type == 2 ~ play_predict_2026 + 4*clean_sheets_predict_2026
+ 6*goals_predict_2026 + 3*assists_predict_2026
- 0.5*goals_against_predict_2026
- concede_2_predict_2026 - concede_4_predict_2026,
element_type == 3 ~ play_predict_2026 + 1*clean_sheets_predict_2026
+ 5*goals_predict_2026 + 3*assists_predict_2026,
element_type == 4 ~ play_predict_2026
+ 4*goals_predict_2026 + 3*assists_predict_2026
) * if_else(is.na(play_chance),1,play_chance/100)
)
player_data |>
arrange(desc(predicted_2026_points))
#| label: export_player_points
write_csv(player_data,"processed_data/player_data.csv")
#|label: import-points-predictions
library(tidyverse)
library(tidymodels)
player_data <- read_csv("processed_data/player_data.csv")
#| label: team-improvement
current_team <- player_data |> filter(
id %in% c(
65,
82,
106,
220,
256,
287,
381,
402,
413,
489,
505,
515,
610,
624,
654
)
)
current_team
# Somewhere along the way people are scoring infinity points - why?
#| label: team-improvement
current_team <- player_data |> filter(
id %in% c(
65,
82,
106,
220,
256,
287,
381,
402,
413,
489,
505,
515,
610,
624,
654
)
) |>
rename(.id = id)
current_team
best_pairwise_swap <- function(
df,        # full player table (ranked_players)
chosen,    # tibble of current picks (has .id)
budget,
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
) {
# Extract chosen IDs from `.id` column in chosen
chosen_ids <- chosen$.id
# Build chosen / unchosen views from df
chosen_tbl <- df %>%
filter(id %in% chosen_ids) %>%
transmute(
out_id    = id,
category  = .data[[cat_col]],
out_cost  = .data[[cost_col]],
out_score = .data[[score_col]]
)
unchosen_tbl <- df %>%
filter(!(id %in% chosen_ids)) %>%
transmute(
in_id    = id,
category = .data[[cat_col]],
in_cost  = .data[[cost_col]],
in_score = .data[[score_col]]
)
# Current totals
current_cost  <- sum(chosen_tbl$out_cost, na.rm = TRUE)
current_score <- sum(chosen_tbl$out_score, na.rm = TRUE)
leftover      <- budget - current_cost
# Join within same category; look for feasible improving swaps
cand_pairs <- inner_join(chosen_tbl, unchosen_tbl, by = "category") %>%
mutate(
delta_cost  = in_cost  - out_cost,
delta_score = in_score - out_score,
feasible    = (delta_cost <= leftover)
) %>%
filter(feasible, delta_score > 0)
if (nrow(cand_pairs) == 0) return(NULL)
# Pick best swap: highest score gain, then lowest extra cost, then best incoming score
best <- cand_pairs %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice(1)
list(
out_id          = best$out_id,
in_id           = best$in_id,
delta_score     = as.numeric(best$delta_score),
delta_cost      = as.numeric(best$delta_cost),
new_total_cost  = as.numeric(current_cost + best$delta_cost),
new_total_score = as.numeric(current_score + best$delta_score)
)
}
best_pairwise_swap(player_data, current_team, budget =1000)
current_team
player_data
best_pairwise_swap <- function(
df,        # full player table (ranked_players)
chosen,    # tibble of current picks (has .id)
budget,
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
) {
# Extract chosen IDs from `.id` column in chosen
chosen_ids <- chosen$.id
# Build chosen / unchosen views from df
chosen_tbl <- df %>%
filter(id %in% chosen_ids) %>%
transmute(
out_id    = id,
out_name = web_name,
category  = .data[[cat_col]],
out_cost  = .data[[cost_col]],
out_score = .data[[score_col]]
)
unchosen_tbl <- df %>%
filter(!(id %in% chosen_ids)) %>%
transmute(
in_id    = id,
in_name = web_name,
category = .data[[cat_col]],
in_cost  = .data[[cost_col]],
in_score = .data[[score_col]]
)
# Current totals
current_cost  <- sum(chosen_tbl$out_cost, na.rm = TRUE)
current_score <- sum(chosen_tbl$out_score, na.rm = TRUE)
leftover      <- budget - current_cost
# Join within same category; look for feasible improving swaps
cand_pairs <- inner_join(chosen_tbl, unchosen_tbl, by = "category") %>%
mutate(
delta_cost  = in_cost  - out_cost,
delta_score = in_score - out_score,
feasible    = (delta_cost <= leftover)
) %>%
filter(feasible, delta_score > 0)
if (nrow(cand_pairs) == 0) return(NULL)
# Pick best swap: highest score gain, then lowest extra cost, then best incoming score
best <- cand_pairs %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice(1)
list(
out_id          = best$out_id,
out_name        = best$out_name,
in_id           = best$in_id,
in_name         = best$in_name
delta_score     = as.numeric(best$delta_score),
best_pairwise_swap <- function(
df,        # full player table (ranked_players)
chosen,    # tibble of current picks (has .id)
budget,
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
) {
# Extract chosen IDs from `.id` column in chosen
chosen_ids <- chosen$.id
# Build chosen / unchosen views from df
chosen_tbl <- df %>%
filter(id %in% chosen_ids) %>%
transmute(
out_id    = id,
out_name = web_name,
category  = .data[[cat_col]],
out_cost  = .data[[cost_col]],
out_score = .data[[score_col]]
)
unchosen_tbl <- df %>%
filter(!(id %in% chosen_ids)) %>%
transmute(
in_id    = id,
in_name = web_name,
category = .data[[cat_col]],
in_cost  = .data[[cost_col]],
in_score = .data[[score_col]]
)
# Current totals
current_cost  <- sum(chosen_tbl$out_cost, na.rm = TRUE)
current_score <- sum(chosen_tbl$out_score, na.rm = TRUE)
leftover      <- budget - current_cost
# Join within same category; look for feasible improving swaps
cand_pairs <- inner_join(chosen_tbl, unchosen_tbl, by = "category") %>%
mutate(
delta_cost  = in_cost  - out_cost,
delta_score = in_score - out_score,
feasible    = (delta_cost <= leftover)
) %>%
filter(feasible, delta_score > 0)
if (nrow(cand_pairs) == 0) return(NULL)
# Pick best swap: highest score gain, then lowest extra cost, then best incoming score
best <- cand_pairs %>%
arrange(desc(delta_score), delta_cost, desc(in_score)) %>%
slice(1)
list(
out_id          = best$out_id,
out_name        = best$out_name,
in_id           = best$in_id,
in_name         = best$in_name,
delta_score     = as.numeric(best$delta_score),
delta_cost      = as.numeric(best$delta_cost),
new_total_cost  = as.numeric(current_cost + best$delta_cost),
new_total_score = as.numeric(current_score + best$delta_score)
)
}
best_pairwise_swap(player_data, current_team, budget =1000)
#| label: team-improvement
current_team <- player_data |> filter(
id %in% c(
65,
82,
106,
220,
256,
287,
381,
402,
427,
489,
505,
515,
610,
624,
654
)
) |>
rename(.id = id)
current_team
current_team |>arrange(desc(predicted_2026_points))
