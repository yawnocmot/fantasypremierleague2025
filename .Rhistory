# --------------------------------------------------
# Build working frame with standardized temp columns
X <- df %>%
transmute(
.id       = .data[[id_col]],
.category = as.character(.data[[cat_col]]),   # ensure character for joining
.cost     = as.numeric(.data[[cost_col]]),
.value    = as.numeric(.data[[score_col]])
)
# Check that all categories present in X exist in targets
miss <- setdiff(unique(X$.category), targets_tbl$.category)
if (length(miss)) {
stop("Missing targets for categories: ", paste(miss, collapse = ", "), call. = FALSE)
}
# helper: run ONE jittered greedy seed
run_one_seed <- function(z_vec) {
# Helper: given alpha, rank within each category and take the top N for that category
pick_with_alpha <- function(alpha) {
base_key <- X$.value - alpha * X$.cost
sigma <- sd(base_key)
if (!is.finite(sigma) || sigma == 0) sigma <- 0
eps   <- rnorm(nrow(X), sd = 1e-6)
key <- base_key + 0.3 * sigma * z_vec + eps  # jitter with sd = 0.2 * sd(key)
cand <- X %>%
mutate(
.key      = key,
.tiebreak = .value / pmax(.cost, 1e-9)
) %>%
arrange(.category, desc(.key), desc(.tiebreak), desc(.value), .cost) %>%
left_join(targets_tbl, by = join_by(.category))
# Slice per category using the joined .target (guaranteed scalar per group)
M_factor <- 2L
chosen <- cand %>%
group_by(.category) %>%
group_modify(~ {
.x <- .x
.x$.target <- as.integer(.x$.target[1])
M <- min(nrow(.x), M_factor * .x$.target)
frontier <- .x[1:M, ]
tau <- max(1, sd(frontier$.key, na.rm = TRUE))
w   <- exp((frontier$.key - max(frontier$.key))/tau)
frontier[sample.int(nrow(frontier), size = .x$.target, prob = w), ]
}) %>%
ungroup()
list(
chosen      = chosen,
total_cost  = sum(chosen$.cost),
total_value = sum(chosen$.value)
)
}
# ---- Binary search on alpha to meet budget ----
alpha_lo  <- 0
alpha_hi  <- 10      # start; will expand if needed
best      <- NULL
# Ensure alpha_hi is tight enough to get under budget
for (k in 1:10) {
trial <- pick_with_alpha(alpha_hi)
best  <- trial
if (trial$total_cost <= budget) break
alpha_hi <- alpha_hi * 2
}
if (best$total_cost > budget) {
warning("Could not meet budget even with strong cost penalty; returning cheapest-by-penalty pick.")
return(list(
selection   = best$chosen %>% select(.id, .category, now_cost = .cost, score = .value),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
))
}
for (it in 1:max_iter) {
alpha_mid <- 0.5 * (alpha_lo + alpha_hi)
trial <- pick_with_alpha(alpha_mid)
if (trial$total_cost <= budget) {
best <- trial
alpha_hi <- alpha_mid
} else {
alpha_lo <- alpha_mid
}
if (abs(trial$total_cost - budget) <= 1e-6 || (alpha_hi - alpha_lo) < 1e-4) break
}
# ----------------------------------------------
# Return tidy outputs
list(
selection   = best$chosen %>%
select(.id, .category, now_cost = .cost, score = .value) %>%
arrange(.category, desc(score)),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
)
}
# --- prepare jitter z-vectors for each run ---
if (is.null(rng_seeds)) {
z_list <- replicate(n_runs, rnorm(nrow(X)), simplify = FALSE)
} else {
stopifnot(length(rng_seeds) >= n_runs)
z_list <- map(seq_len(n_runs), ~ { set.seed(rng_seeds[.x]); rnorm(nrow(X)) })
}
# ---  run the greedy seed multiple times and store ---
seeds <- map(z_list, run_one_seed)
summary <- tibble(
run         = seq_len(n_runs),
total_cost  = map_dbl(seeds, "total_cost"),
total_value = map_dbl(seeds, "total_value"),
alpha_used  = map_dbl(seeds, "alpha_used")
)
#--- order seeds by total_value (descending) ---
order_idx <- order(summary$total_value, decreasing = TRUE)
seeds <- seeds[order_idx]
summary <- summary[order_idx, ] %>%
mutate(run = seq_len(n()))
list(seeds = seeds, summary = summary)
}
phaseA <- greedy_seed_hard_capped(
df        = ranked_players,
budget    = budget,
n_runs    = 24,
rng_seeds = sample.int(1e6, 24),
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
)
greedy_seed_hard_capped <- function(
df,
budget,
n_runs = 5,
rng_seeds = NULL,
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points",
max_iter  = 40
) {
# ---- Hard-coded category targets (EDIT THESE) ----
# Example FPL-style squad shape that sums to 15:
targets_tbl <- tribble(
~.category, ~.target,
"GK",        2L,
"DEF",        5L,
"MID",        5L,
"FWD",        3L
)
# --------------------------------------------------
# Build working frame with standardized temp columns
X <- df %>%
transmute(
.id       = .data[[id_col]],
.category = as.character(.data[[cat_col]]),   # ensure character for joining
.cost     = as.numeric(.data[[cost_col]]),
.value    = as.numeric(.data[[score_col]])
)
# Check that all categories present in X exist in targets
miss <- setdiff(unique(X$.category), targets_tbl$.category)
if (length(miss)) {
stop("Missing targets for categories: ", paste(miss, collapse = ", "), call. = FALSE)
}
# helper: run ONE jittered greedy seed
run_one_seed <- function(z_vec) {
# Helper: given alpha, rank within each category and take the top N for that category
pick_with_alpha <- function(alpha) {
base_key <- X$.value - alpha * X$.cost
sigma <- sd(base_key)
if (!is.finite(sigma) || sigma == 0) sigma <- 0
eps   <- rnorm(nrow(X), sd = 1e-6)
key <- base_key + 0.3 * sigma * z_vec + eps  # jitter with sd = 0.2 * sd(key)
cand <- X %>%
mutate(
.key      = key,
.tiebreak = .value / pmax(.cost, 1e-9)
) %>%
arrange(.category, desc(.key), desc(.tiebreak), desc(.value), .cost) %>%
left_join(targets_tbl, by = join_by(.category))
# Slice per category using the joined .target (guaranteed scalar per group)
M_factor <- 2L
chosen <- cand %>%
group_by(.category) %>%
group_modify(~ {
.x <- .x
t <- as.integer(.x$.target[1])            # required picks for this category
if (is.na(t) || t <= 0L) return(.x[0, ])  # nothing to pick
# frontier size: top M rows within this category
M <- min(nrow(.x), max(t, M_factor * t))
frontier <- .x[1:M, , drop = FALSE]
# compute softmax-like weights from .key
k <- frontier$.key
k[!is.finite(k)] <- min(k[is.finite(k)], na.rm = TRUE)
kmax <- max(k, na.rm = TRUE)
tau  <- sd(k, na.rm = TRUE)
if (!is.finite(tau) || tau <= 0) tau <- 1  # avoid divide-by-zero
w <- exp((k - kmax) / tau)
# fallbacks if weights misbehave
if (any(!is.finite(w)) || any(is.na(w)) || all(w <= 0)) {
w <- rep(1, length(k))
}
# sample WITHOUT replacement using 'sample()', not sample.int()
idx <- sample(seq_len(nrow(frontier)), size = t, replace = FALSE, prob = w)
frontier[idx, , drop = FALSE]
}) %>%
ungroup()
ungroup()
list(
chosen      = chosen,
total_cost  = sum(chosen$.cost),
total_value = sum(chosen$.value)
)
}
# ---- Binary search on alpha to meet budget ----
alpha_lo  <- 0
alpha_hi  <- 10      # start; will expand if needed
best      <- NULL
# Ensure alpha_hi is tight enough to get under budget
for (k in 1:10) {
trial <- pick_with_alpha(alpha_hi)
best  <- trial
if (trial$total_cost <= budget) break
alpha_hi <- alpha_hi * 2
}
if (best$total_cost > budget) {
warning("Could not meet budget even with strong cost penalty; returning cheapest-by-penalty pick.")
return(list(
selection   = best$chosen %>% select(.id, .category, now_cost = .cost, score = .value),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
))
}
for (it in 1:max_iter) {
alpha_mid <- 0.5 * (alpha_lo + alpha_hi)
trial <- pick_with_alpha(alpha_mid)
if (trial$total_cost <= budget) {
best <- trial
alpha_hi <- alpha_mid
} else {
alpha_lo <- alpha_mid
}
if (abs(trial$total_cost - budget) <= 1e-6 || (alpha_hi - alpha_lo) < 1e-4) break
}
# ----------------------------------------------
# Return tidy outputs
list(
selection   = best$chosen %>%
select(.id, .category, now_cost = .cost, score = .value) %>%
arrange(.category, desc(score)),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
)
}
# --- prepare jitter z-vectors for each run ---
if (is.null(rng_seeds)) {
z_list <- replicate(n_runs, rnorm(nrow(X)), simplify = FALSE)
} else {
stopifnot(length(rng_seeds) >= n_runs)
z_list <- map(seq_len(n_runs), ~ { set.seed(rng_seeds[.x]); rnorm(nrow(X)) })
}
# ---  run the greedy seed multiple times and store ---
seeds <- map(z_list, run_one_seed)
summary <- tibble(
run         = seq_len(n_runs),
total_cost  = map_dbl(seeds, "total_cost"),
total_value = map_dbl(seeds, "total_value"),
alpha_used  = map_dbl(seeds, "alpha_used")
)
#--- order seeds by total_value (descending) ---
order_idx <- order(summary$total_value, decreasing = TRUE)
seeds <- seeds[order_idx]
summary <- summary[order_idx, ] %>%
mutate(run = seq_len(n()))
list(seeds = seeds, summary = summary)
}
seeds <- greedy_seed_hard_capped(ranked_players,
budget,
n=50
)
greedy_seed_hard_capped <- function(
df,
budget,
n_runs = 5,
rng_seeds = NULL,
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points",
max_iter  = 40
) {
# ---- Hard-coded category targets (EDIT THESE) ----
# Example FPL-style squad shape that sums to 15:
targets_tbl <- tribble(
~.category, ~.target,
"GK",        2L,
"DEF",        5L,
"MID",        5L,
"FWD",        3L
)
# --------------------------------------------------
# Build working frame with standardized temp columns
X <- df %>%
transmute(
.id       = .data[[id_col]],
.category = as.character(.data[[cat_col]]),   # ensure character for joining
.cost     = as.numeric(.data[[cost_col]]),
.value    = as.numeric(.data[[score_col]])
)
# Check that all categories present in X exist in targets
miss <- setdiff(unique(X$.category), targets_tbl$.category)
if (length(miss)) {
stop("Missing targets for categories: ", paste(miss, collapse = ", "), call. = FALSE)
}
# helper: run ONE jittered greedy seed
run_one_seed <- function(z_vec) {
# Helper: given alpha, rank within each category and take the top N for that category
pick_with_alpha <- function(alpha) {
base_key <- X$.value - alpha * X$.cost
sigma <- sd(base_key)
if (!is.finite(sigma) || sigma == 0) sigma <- 0
eps   <- rnorm(nrow(X), sd = 1e-6)
key <- base_key + 0.3 * sigma * z_vec + eps  # jitter with sd = 0.2 * sd(key)
cand <- X %>%
mutate(
.key      = key,
.tiebreak = .value / pmax(.cost, 1e-9)
) %>%
arrange(.category, desc(.key), desc(.tiebreak), desc(.value), .cost) %>%
left_join(targets_tbl, by = join_by(.category))
# Slice per category using the joined .target (guaranteed scalar per group)
M_factor <- 2L
chosen <- cand %>%
group_by(.category) %>%
group_modify(~ {
.x <- .x
t <- as.integer(.x$.target[1])            # required picks for this category
if (is.na(t) || t <= 0L) return(.x[0, ])  # nothing to pick
# frontier size: top M rows within this category
M <- min(nrow(.x), max(t, M_factor * t))
frontier <- .x[1:M, , drop = FALSE]
# compute softmax-like weights from .key
k <- frontier$.key
k[!is.finite(k)] <- min(k[is.finite(k)], na.rm = TRUE)
kmax <- max(k, na.rm = TRUE)
tau  <- sd(k, na.rm = TRUE)
if (!is.finite(tau) || tau <= 0) tau <- 1  # avoid divide-by-zero
w <- exp((k - kmax) / tau)
# fallbacks if weights misbehave
if (any(!is.finite(w)) || any(is.na(w)) || all(w <= 0)) {
w <- rep(1, length(k))
}
# sample WITHOUT replacement using 'sample()', not sample.int()
idx <- sample(seq_len(nrow(frontier)), size = t, replace = FALSE, prob = w)
frontier[idx, , drop = FALSE]
}) %>%
ungroup()
list(
chosen      = chosen,
total_cost  = sum(chosen$.cost),
total_value = sum(chosen$.value)
)
}
# ---- Binary search on alpha to meet budget ----
alpha_lo  <- 0
alpha_hi  <- 10      # start; will expand if needed
best      <- NULL
# Ensure alpha_hi is tight enough to get under budget
for (k in 1:10) {
trial <- pick_with_alpha(alpha_hi)
best  <- trial
if (trial$total_cost <= budget) break
alpha_hi <- alpha_hi * 2
}
if (best$total_cost > budget) {
warning("Could not meet budget even with strong cost penalty; returning cheapest-by-penalty pick.")
return(list(
selection   = best$chosen %>% select(.id, .category, now_cost = .cost, score = .value),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
))
}
for (it in 1:max_iter) {
alpha_mid <- 0.5 * (alpha_lo + alpha_hi)
trial <- pick_with_alpha(alpha_mid)
if (trial$total_cost <= budget) {
best <- trial
alpha_hi <- alpha_mid
} else {
alpha_lo <- alpha_mid
}
if (abs(trial$total_cost - budget) <= 1e-6 || (alpha_hi - alpha_lo) < 1e-4) break
}
# ----------------------------------------------
# Return tidy outputs
list(
selection   = best$chosen %>%
select(.id, .category, now_cost = .cost, score = .value) %>%
arrange(.category, desc(score)),
total_cost  = best$total_cost,
total_value = best$total_value,
alpha_used  = alpha_hi,
by_category = best$chosen %>% count(.category, name = "picked_n") %>% arrange(.category)
)
}
# --- prepare jitter z-vectors for each run ---
if (is.null(rng_seeds)) {
z_list <- replicate(n_runs, rnorm(nrow(X)), simplify = FALSE)
} else {
stopifnot(length(rng_seeds) >= n_runs)
z_list <- map(seq_len(n_runs), ~ { set.seed(rng_seeds[.x]); rnorm(nrow(X)) })
}
# ---  run the greedy seed multiple times and store ---
seeds <- map(z_list, run_one_seed)
summary <- tibble(
run         = seq_len(n_runs),
total_cost  = map_dbl(seeds, "total_cost"),
total_value = map_dbl(seeds, "total_value"),
alpha_used  = map_dbl(seeds, "alpha_used")
)
#--- order seeds by total_value (descending) ---
order_idx <- order(summary$total_value, decreasing = TRUE)
seeds <- seeds[order_idx]
summary <- summary[order_idx, ] %>%
mutate(run = seq_len(n()))
list(seeds = seeds, summary = summary)
}
seeds <- greedy_seed_hard_capped(ranked_players,
budget,
n=5
)
# Give the outcome of the best changes
seeds$summary
phaseA <- greedy_seed_hard_capped(
df        = ranked_players,
budget    = budget,
n_runs    = 24,
rng_seeds = sample.int(1e6, 24),
id_col    = "id",
cat_col   = "element_name",
cost_col  = "now_cost",
score_col = "predicted_2026_points"
)
anneal_A <- imap(seed_runs$seeds, ~ {
set.seed(1000 + .y)
stochastic_local_search(
ranked_players = ranked_players,
team           = .x$selection,   # has .id
budget         = budget,
n_steps        = 1000,            # shallow
cat_col        = "element_name",
cost_col       = "now_cost",
score_col      = "predicted_2026_points",
tabu_len       = 2,
pick_bias      = 0.8
)
})
anneal_A <- imap(phaseA$seeds, ~ {
set.seed(1000 + .y)
stochastic_local_search(
ranked_players = ranked_players,
team           = .x$selection,   # has .id
budget         = budget,
n_steps        = 1000,            # shallow
cat_col        = "element_name",
cost_col       = "now_cost",
score_col      = "predicted_2026_points",
tabu_len       = 2,
pick_bias      = 0.8
)
})
summary_A <- tibble(
idx         = seq_along(anneal_A),
total_score = map_dbl(anneal_A, "total_score"),
total_cost  = map_dbl(anneal_A, "total_cost")
) %>% arrange(desc(total_score))
summary_A
# ---- Phase B: deepen the best 5 seeds × 3000 steps (≈ 5–7 mins) ----
top_k <- head(summary_A$idx, 1)
anneal_B <- map(top_k, ~
stochastic_local_search(
ranked_players = ranked_players,
team           = phaseA$seeds[[.x]]$selection,
budget         = budget,
n_steps        = 3000,           # deep
cat_col        = "element_name",
cost_col       = "now_cost",
score_col      = "predicted_2026_points",
tabu_len       = 2,
pick_bias      = 0.6
)
)
summary_B <- tibble(
seed_from_A  = top_k,
total_score  = map_dbl(anneal_B, "total_score"),
total_cost   = map_dbl(anneal_B, "total_cost")
) %>% arrange(desc(total_score))
summary_B
# ---- Final pick ----
best_idx <- which.max(map_dbl(anneal_B, "total_score"))
best_team  <- anneal_B[[best_idx]]$team
best_score <- anneal_B[[best_idx]]$total_score
best_cost  <- anneal_B[[best_idx]]$total_cost
best_score
best_cost
best_team
best_team |> left_join(ranked_players|> select(id, web_name), by = join_by(.id == id))|> print(n=16)
best_team |> left_join(ranked_players|> select(id, web_name), by = join_by(id == id))|> print(n=16)
best_team |> left_join(ranked_players|> select(id, web_name), by = join_by(id == id))|> print(n=16)
q()
